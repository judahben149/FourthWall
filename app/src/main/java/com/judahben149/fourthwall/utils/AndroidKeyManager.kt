package com.judahben149.fourthwall.utils

import web5.sdk.crypto.Crypto
import web5.sdk.crypto.KeyGenOptions
import web5.sdk.crypto.KeyManager


import com.nimbusds.jose.jwk.JWK

import android.content.Context
import android.content.SharedPreferences
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKeys
import tbdex.sdk.protocol.serialization.Json
import web5.sdk.crypto.AlgorithmId
import web5.sdk.crypto.jwk.Jwk


/**
 * A class for managing cryptographic keys with Android Encrypted Prefs.
 * Android will encrypt and store the key which is generated by the web5 code.
 *
 * This doesn't use HSM to host the private key currently.
 * It is instead generated in web5.crypto code and then stored.
 *
 * - Generate private keys ([generatePrivateKey])
 * - Retrieve public keys ([getPublicKey])
 * - Sign payloads ([sign])
 *
 * ### Example Usage:
 * ```
 * val keyManager = AndroidKeyManager()
 * val keyID = keyManager.generatePrivateKey(JWSAlgorithm.EdDSA, Curve.Ed25519)
 * val publicKey = keyManager.getPublicKey(keyID)
 * ```
 *
 * ### Notes:
 * - Keys are stored in encrypted preferences and are not accessible to other apps.
 */
class AndroidKeyManager : KeyManager {

    private val context: Context

    private fun getEncryptedSharedPreferences(context: Context): SharedPreferences {
        // Choose a filename and a master key alias
        val fileName = "encrypted_shared_prefs"
        val masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)

        return EncryptedSharedPreferences.create(
            fileName,
            masterKeyAlias,
            context,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }

    private fun saveSecret(context: Context, key: String, secret: String) {
        val encryptedPrefs = getEncryptedSharedPreferences(context)
        with(encryptedPrefs.edit()) {
            putString(key, secret)
            apply()
        }
    }

    private fun getSecret(context: Context, key: String): String? {
        val encryptedPrefs = getEncryptedSharedPreferences(context)
        return encryptedPrefs.getString(key, null)
    }

    /*
     * Constructor that takes a context as a parameter.
     */
    constructor (context: Context) {
        this.context = context
    }

    /**
     * Generates a private key using specified algorithm and curve, and stores it in the in-memory keyStore.
     *
     * @param algorithm The JWA algorithm identifier.
     * @param curve The elliptic curve. Null for algorithms that do not use elliptic curves.
     * @param options Options for key generation, may include specific parameters relevant to the algorithm.
     * @return The key ID of the generated private key.
     */
    override fun generatePrivateKey(algorithmId: AlgorithmId, options: KeyGenOptions?): String {
        val jwk = Crypto.generatePrivateKey(algorithmId, options)
        val kid = jwk.kid ?: jwk.computeThumbprint()
        saveSecret(context, kid, Json.stringify(jwk))
        return kid
    }


    /**
     * Computes and returns a public key corresponding to the private key identified by the provided keyAlias.
     *
     * @param keyAlias The alias (key ID) of the private key stored in the keyStore.
     * @return The computed public key as a JWK object.
     * @throws Exception if a key with the provided alias is not found in the keyStore.
     */
    override fun getPublicKey(keyAlias: String): Jwk {
        val privateKey = getPrivateKey(keyAlias)
        return Crypto.computePublicKey(privateKey)
    }

    /**
     * Signs a payload using the private key identified by the provided keyAlias.
     *
     * The implementation of this method is not yet provided and invoking it will throw a [NotImplementedError].
     *
     * @param keyAlias The alias (key ID) of the private key stored in the keyStore.
     * @param signingInput The data to be signed.
     * @return The signature in JWS R+S format
     */
    override fun sign(keyAlias: String, signingInput: ByteArray): ByteArray {
        val privateKey = getPrivateKey(keyAlias)
        return Crypto.sign(privateKey, signingInput)
    }

    /**
     * Return the alias of [publicKey], as was originally returned by [generatePrivateKey].
     *
     * @param publicKey A public key in JWK (JSON Web Key) format
     * @return The alias belonging to [publicKey]
     * @throws IllegalArgumentException if the key is not known to the [KeyManager]
     */
    override fun getDeterministicAlias(publicKey: Jwk): String {
        val kid = publicKey.kid ?: publicKey.computeThumbprint()
        val encryptedSharedPreferences = getEncryptedSharedPreferences(context)
        require(encryptedSharedPreferences.contains(kid)) {
            "key with alias $kid not found"
        }
        return kid
    }

    private fun getPrivateKey(keyAlias: String): Jwk {
        val maybeJwkString = getSecret(context, keyAlias)
        val jwk = Json.jsonMapper.readValue(maybeJwkString, Jwk::class.java)
        return jwk
    }




}
